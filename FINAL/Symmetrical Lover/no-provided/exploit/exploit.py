from pwn import *
from utils import *

proc = remote("127.0.0.1", 32787)


def send(data: bytes):
    global proc
    print("[>] sent:")
    print(data.decode())
    proc.sendline(data)


def recv(until: bytes) -> str:
    global proc
    result = proc.recvuntil(until).decode()
    print("[<] received:")
    print(result)
    return result


def forge_authcode(old_authcode):
    old_token = b"debug=False;pseu"
    new_token = b"debug=True ;pseu"
    xor_result = xor(bytes.fromhex(old_authcode), old_token)
    forged_authcode = xor(xor_result, new_token)
    return forged_authcode.hex()


def list_basket():
    send(b"1")
    recv(b"Choice: ")


def add_to_cart(item: str, authcode: str, debug_mode=False) -> str:
    send(b"2")
    recv(b"person: ")
    send(authcode.encode())
    recv(b"Material: ")
    send(item.encode())
    cipher = recv(b"Choice: ")
    if debug_mode:
        cipher = cipher.split("DEBUG :  ")[1].split(" ")[0]
    return cipher


def take_order():
    send(b"3")
    # End the communication
    print(proc.recvall(1))


def create_collision(cipher: str, item: str, authcode: str):
    item = padding(bytes.fromhex(item))
    authcode = bytes.fromhex(authcode)
    cipher = bytes.fromhex(cipher)
    return item.hex() + xor(authcode, cipher).hex()


recv(b"pseudo : ")
send(
    b"a" * 7
)  # good padding to not interfere with the parsing of the logged property neither the debug property in the token
authcode = recv(b"Choice: ").split(" : ")[1].split("\n\n")[0]

needle = b"needle".hex()
battery = b"battery".hex()
watch_strap = b"watch-strap".hex()
watch_dial = b"watch-dial".hex()

debug_authcode = forge_authcode(authcode)
assert len(debug_authcode) == len(authcode)
print("[+] Forged authcode done.")


cipher_needle = add_to_cart(needle, debug_authcode, True)
add_to_cart(battery, authcode)
add_to_cart(watch_dial, authcode)
add_to_cart(watch_strap, authcode)
add_to_cart(create_collision(cipher_needle, needle, authcode), authcode)
list_basket()
take_order()
